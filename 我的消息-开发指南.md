# 「我的消息」功能开发指南（完整方案）

> 基于若依 RuoYi-Vue-Pro，混合方案（代码生成骨架 + 手工改造），支持：单聊、群聊、文件传输、已读未读、角色权限控制。

---

## 一、WebSocket 说明（必读）

### 1.1 WebSocket 是什么

WebSocket 是浏览器与服务器之间的**长连接通信协议**，服务端可以主动向客户端推送数据，不需要客户端轮询。

| 对比项 | HTTP | WebSocket |
|--------|------|-----------|
| 连接 | 短连接，请求完即断 | 长连接，保持打开 |
| 发起方 | 只能客户端发起 | 双向，服务端可主动推 |
| 典型场景 | 查数据、表单 | 实时通知、聊天 |

### 1.2 WebSocket 消息存在哪里

**结论：WebSocket 框架本身不落库，消息是临时的网络传输。**

- 用户在线 → 能收到推送
- 用户离线 → 消息丢失，无任何记录
- **没有任何历史记录**，因为从未写入数据库

### 1.3 正确做法

```
发消息
  ↓
① 先写入数据库（im_message 表）  ← 历史记录在这里
  ↓
② 再调用 WebSocketSenderApi 推送给在线成员
  ↓
在线成员：实时弹出
离线成员：下次打开「我的消息」，从数据库拉取历史
```

WebSocket 只是加速通道，数据库才是所有历史消息的根本。

---

## 二、为什么需要三张表

### 单表（已读问题）的局限

如果只有 `im_message` 一张表，在消息里加一个 `read_status` 字段：

- 单聊：只有两人，一个发一个收，`read_status` 还能凑合
- **群聊 5 人**：A 发了一条消息，B 已读，C/D/E 未读。同一条消息对不同人的已读状态不同 → **一个字段无法记录 5 个人各自的已读状态**

因此需要把「会话」「成员」「消息」三个概念分开。

### 三表职责

| 表 | 职责 |
|----|------|
| `im_conversation`（会话） | 描述一个聊天的基本信息：是单聊还是群聊、叫什么名字 |
| `im_conversation_member`（会话成员） | 描述某人在某会话中的状态：何时加入、读到哪条消息了 |
| `im_message`（消息） | 消息内容本身：文本/图片/文件、谁发的、发给哪个会话 |

### 关系图

```
im_conversation（1）─── im_message（N）
       │
im_conversation_member（N，每个成员一行）
       │
       └── last_read_message_id（该成员读到哪条消息了）
```

---

## 三、表结构设计（完整版）

### 3.1 会话表 `im_conversation`

```sql
CREATE TABLE `im_conversation` (
  `id`                    bigint       NOT NULL AUTO_INCREMENT COMMENT '会话ID',
  `type`                  tinyint      NOT NULL DEFAULT 1 COMMENT '类型：1=单聊 2=群聊',
  `name`                  varchar(100) NOT NULL DEFAULT '' COMMENT '会话名称（单聊为空，群聊必填）',
  `avatar`                varchar(500) NOT NULL DEFAULT '' COMMENT '会话头像（单聊为空，群聊可设）',
  `owner_id`              bigint       NOT NULL DEFAULT 0 COMMENT '群主ID（单聊为0）',
  `notice`                varchar(500) NOT NULL DEFAULT '' COMMENT '群公告（单聊为空）',
  `last_message_id`       bigint       NOT NULL DEFAULT 0 COMMENT '最后一条消息ID（冗余，用于排序）',
  `last_message_content`  varchar(200) NOT NULL DEFAULT '' COMMENT '最后一条消息摘要（冗余，用于会话列表展示）',
  `last_message_time`     datetime     NULL COMMENT '最后一条消息时间（冗余，用于排序）',
  `creator`    varchar(64)  DEFAULT '' COMMENT '创建者',
  `create_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updater`    varchar(64)  DEFAULT '' COMMENT '更新者',
  `update_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted`    bit(1)       NOT NULL DEFAULT b'0' COMMENT '是否删除',
  `tenant_id`  bigint       NOT NULL DEFAULT 0 COMMENT '租户编号',
  PRIMARY KEY (`id`),
  KEY `idx_last_message_time` (`last_message_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='IM 会话表';
```

**设计说明**：
- `type=1` 单聊：`name/avatar/owner_id/notice` 均无意义，由成员信息决定展示
- `type=2` 群聊：必须有 `name`，`owner_id` 是群主
- `last_message_*` 三个字段是**冗余字段**，写入新消息时同步更新，目的是让「会话列表」查询时不必关联 `im_message` 表，直接展示

---

### 3.2 会话成员表 `im_conversation_member`

```sql
CREATE TABLE `im_conversation_member` (
  `id`                  bigint   NOT NULL AUTO_INCREMENT COMMENT '主键',
  `conversation_id`     bigint   NOT NULL COMMENT '会话ID',
  `user_id`             bigint   NOT NULL COMMENT '成员用户ID',
  `member_role`         tinyint  NOT NULL DEFAULT 0 COMMENT '角色：0=普通成员 1=群主 2=群管理员',
  `last_read_message_id` bigint  NOT NULL DEFAULT 0 COMMENT '该成员最后阅读的消息ID（用于计算未读数）',
  `is_muted`            bit(1)   NOT NULL DEFAULT b'0' COMMENT '是否被禁言',
  `is_pinned`           bit(1)   NOT NULL DEFAULT b'0' COMMENT '是否置顶',
  `is_disturb`          bit(1)   NOT NULL DEFAULT b'0' COMMENT '是否免打扰',
  `join_time`           datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '加入时间',
  `creator`    varchar(64)  DEFAULT '' COMMENT '创建者',
  `create_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updater`    varchar(64)  DEFAULT '' COMMENT '更新者',
  `update_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted`    bit(1)       NOT NULL DEFAULT b'0' COMMENT '是否删除',
  `tenant_id`  bigint       NOT NULL DEFAULT 0 COMMENT '租户编号',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_conversation_user` (`conversation_id`, `user_id`),
  KEY `idx_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='IM 会话成员表';
```

**设计说明**：
- 每个成员在每个会话中有一行
- `last_read_message_id`：该成员最后读到哪条消息。**未读数 = 该会话中 id > last_read_message_id 且 sender_id != 本人 的消息数**
- `UNIQUE KEY (conversation_id, user_id)`：防止同一人在同一会话里重复加入
- 单聊：两人各一行；群聊：N 人就有 N 行

---

### 3.3 消息表 `im_message`

```sql
CREATE TABLE `im_message` (
  `id`              bigint        NOT NULL AUTO_INCREMENT COMMENT '消息ID',
  `conversation_id` bigint        NOT NULL COMMENT '所属会话ID',
  `sender_id`       bigint        NOT NULL COMMENT '发送人用户ID',
  `content_type`    tinyint       NOT NULL DEFAULT 1 COMMENT '消息类型：1=文本 2=图片 3=文件 4=系统消息',
  `content`         varchar(4000) NOT NULL DEFAULT '' COMMENT '消息内容（文本存原文；图片/文件存 URL；系统消息存描述）',
  `file_name`       varchar(255)  NOT NULL DEFAULT '' COMMENT '文件原始名称（type=3时有效）',
  `file_size`       bigint        NOT NULL DEFAULT 0 COMMENT '文件大小字节（type=3时有效）',
  `status`          tinyint       NOT NULL DEFAULT 0 COMMENT '消息状态：0=正常 1=已撤回',
  `creator`    varchar(64)  DEFAULT '' COMMENT '创建者',
  `create_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updater`    varchar(64)  DEFAULT '' COMMENT '更新者',
  `update_time` datetime    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted`    bit(1)       NOT NULL DEFAULT b'0' COMMENT '是否删除',
  `tenant_id`  bigint       NOT NULL DEFAULT 0 COMMENT '租户编号',
  PRIMARY KEY (`id`),
  KEY `idx_conversation_id` (`conversation_id`, `id`),
  KEY `idx_sender_id` (`sender_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='IM 消息表';
```

**设计说明**：
- `im_message` 不存接收人，接收对象由 `im_conversation_member` 决定（所有在该会话的成员都是接收方）
- `content` 字段：
  - 文本：直接存文字
  - 图片：存图片 URL（上传后由 `FileApi` 返回）
  - 文件：存文件 URL，配合 `file_name`/`file_size` 展示
  - 系统消息：如「XXX 加入了群聊」等
- `idx_conversation_id` 联合索引：按会话分页查消息，性能好

---

## 四、核心业务逻辑

### 4.1 单聊：如何防止创建重复会话

#### 4.1.1 什么是「重复会话」

A 和 B 两个人聊天，理想情况是：**无论谁先发起，都只有一个会话**，所有消息都在这一个会话里。

如果不去重，可能出现：
- A 点「和 B 聊天」→ 系统创建会话 1
- B 点「和 A 聊天」→ 系统又创建会话 2
- 结果：A 和 B 之间有两个会话，消息被拆成两段，体验混乱

**防止重复 = 保证「A 和 B」之间永远只有一个会话。**

#### 4.1.2 实现逻辑

用户 A 点击「和 B 聊天」时：

1. **先查**：是否存在 type=1（单聊）且成员只有 A、B 的会话？
2. **若存在** → 直接返回该会话 ID，不再新建
3. **若不存在** → 新建会话，插入两条成员记录（A 一条、B 一条）

**查询 SQL**：
```sql
SELECT c.id 
FROM im_conversation c
JOIN im_conversation_member m1 ON c.id = m1.conversation_id AND m1.user_id = A
JOIN im_conversation_member m2 ON c.id = m2.conversation_id AND m2.user_id = B
WHERE c.type = 1 AND c.deleted = 0
LIMIT 1
```

含义：找一个单聊会话，其中成员同时包含 A 和 B。  
有结果 → 说明已有会话，直接复用；  
无结果 → 新建会话。

### 4.2 已读/未读计数

**接收者视角**（某人在某会话的未读数）：
```
SELECT COUNT(*) FROM im_message
WHERE conversation_id = ? 
  AND id > (SELECT last_read_message_id FROM im_conversation_member WHERE conversation_id=? AND user_id=?) 
  AND sender_id != 当前用户ID
  AND deleted = 0
```

用户打开会话后，调用「标记已读」接口：
```
UPDATE im_conversation_member
SET last_read_message_id = (SELECT MAX(id) FROM im_message WHERE conversation_id = ? AND deleted=0)
WHERE conversation_id = ? AND user_id = ?
```

**发送者视角**（群聊消息的已读/未读详情，见 4.2.1）。

---

#### 4.2.1 群聊：发送者查看「谁已读 / 谁未读」（双模式切换）

群聊中，**发送者**需要看到自己发的消息被多少人读了、具体是谁。**接收者**只需看到自己是否已读。

| 角色 | 展示方式 |
|------|----------|
| 发送者 | 显示「2/4 已读」，可展开查看「谁已读」或「谁未读」 |
| 接收者 | 仅显示「已读」或「未读」 |

**判断逻辑**（基于 `last_read_message_id`）：
- 成员对某条消息「已读」⇔ 该成员的 `last_read_message_id >= 该消息ID`
- 成员对某条消息「未读」⇔ 该成员的 `last_read_message_id < 该消息ID`
- 统计时排除发送者本人

**接口设计**：

```
GET /message/{messageId}/read-status
返回：{
  "readCount": 2,
  "unreadCount": 2,
  "totalCount": 4,
  "readUserList": [{"userId": 2, "nickname": "张三"}, {"userId": 3, "nickname": "李四"}],
  "unreadUserList": [{"userId": 4, "nickname": "王五"}, {"userId": 5, "nickname": "赵六"}]
}
```

**前端双模式切换**：

| 模式 | 默认展示 | 点击/悬停展开 |
|------|----------|----------------|
| 模式一 | 「2/4 已读」 | 张三、李四 已读 |
| 模式二 | 「2/4 已读」 | 王五、赵六 未读 |

实现方式：前端维护一个 `readStatusDisplayMode`（如 `'read'` / `'unread'`），点击「2/4 已读」时切换，展开对应列表。单聊无需此功能（只有一人，已读即对方已读）。

### 4.3 会话列表展示

```
SELECT c.*, m.last_read_message_id, m.is_pinned, m.is_disturb
FROM im_conversation c
JOIN im_conversation_member m ON c.id = m.conversation_id
WHERE m.user_id = 当前用户ID AND m.deleted = 0 AND c.deleted = 0
ORDER BY m.is_pinned DESC, c.last_message_time DESC
```

### 4.4 发消息完整流程

```
① 校验：当前用户是否在该会话的成员表中
② 写入 im_message
③ 更新 im_conversation 的 last_message_id / last_message_content / last_message_time
④ 通过 WebSocketSenderApi 推送给会话内所有在线成员
    → 遍历 im_conversation_member 中该 conversation_id 的所有用户
    → 逐一调用 webSocketSenderApi.sendObject(userId, "im-message", messageVO)
```

---

## 五、权限设计

### 5.1 接口权限

| 接口 | 权限标识 | 说明 |
|------|----------|------|
| 查看会话列表 | `system:im:query` | 所有用户 |
| 查看消息历史 | `system:im:query` | 所有用户 |
| 发送消息 | `system:im:send` | 所有用户 |
| 创建单聊 | `system:im:create` | 所有用户 |
| 创建群聊 | `system:im:create-group` | 可限制角色 |
| 解散群聊 | `system:im:delete-group` | 群主/管理员 |
| 踢人/禁言 | `system:im:manage-member` | 群主/管理员 |

### 5.2 在代码中区分角色权限

Controller 示例：

```java
// 所有已登录用户可发消息
@PreAuthorize("@ss.hasPermission('system:im:send')")
public CommonResult<Long> sendMessage(...)

// 只有被授权角色可建群
@PreAuthorize("@ss.hasPermission('system:im:create-group')")
public CommonResult<Long> createGroup(...)
```

在「系统管理 → 角色管理」中，针对不同角色分配是否有 `system:im:create-group` 这条权限。

### 5.3 数据权限

Service 层查询时必须加**当前用户过滤**，防止用户看到不属于他的会话和消息：

```java
// 查会话列表：只查当前用户参与的会话
WHERE m.user_id = getLoginUserId()

// 查消息：先验证当前用户是该会话成员，否则拒绝
```

---

## 六、开发步骤（完整顺序）

### 步骤总览

| 步 | 内容 | 备注 |
|----|------|------|
| 1 | 建三张表 | 先执行 SQL |
| 2 | 分别代码生成三张表 | 得到 3 个 zip |
| 3 | 解压并放入 system 模块 | 按路径放置 |
| 4 | 后端改造 | 删减+新增接口 |
| 5 | 前端改造 | 重写为聊天界面 |
| 6 | 建菜单 | 代码就绪后再建 |
| 7 | 接入 WebSocket（可选） | 后期加 |

---

### 步骤 1：建表

执行上面三张表的 SQL（顺序：先建 `im_conversation`，再建 `im_conversation_member`，最后建 `im_message`）。

---

### 步骤 2：代码生成（三张表分别生成）

进入 **基础设施 → 代码生成**，对三张表分别操作：

**表 1：`im_conversation`**

| 配置项 | 推荐值 |
|--------|--------|
| 生成模块名 | `system` |
| 生成业务名 | `conversation` |
| 生成包路径 | `admin.im` |
| 模板类型 | 单表 |

**表 2：`im_conversation_member`**

| 配置项 | 推荐值 |
|--------|--------|
| 生成模块名 | `system` |
| 生成业务名 | `conversationMember` |
| 生成包路径 | `admin.im` |
| 模板类型 | 单表 |

**表 3：`im_message`**

| 配置项 | 推荐值 |
|--------|--------|
| 生成模块名 | `system` |
| 生成业务名 | `message` |
| 生成包路径 | `admin.im` |
| 模板类型 | 单表 |

每张表下载一个 zip，共 3 个。

---

### 步骤 3：解压放入项目

解压每个 zip，按路径放置（以项目根目录为基准）。

**后端结构（yudao-module-system 模块）**：

```
yudao-module-system/src/main/java/cn/iocoder/yudao/module/system/
├── controller/admin/im/
│   ├── ImConversationController.java       ← 会话接口
│   ├── ImConversationMemberController.java ← 成员接口
│   ├── ImMessageController.java            ← 消息接口
│   └── vo/
│       ├── conversation/                   ← 会话 VO
│       ├── member/                         ← 成员 VO
│       └── message/                        ← 消息 VO
├── service/im/
│   ├── ImConversationService.java
│   ├── ImConversationServiceImpl.java
│   ├── ImConversationMemberService.java
│   ├── ImConversationMemberServiceImpl.java
│   ├── ImMessageService.java
│   └── ImMessageServiceImpl.java
└── dal/
    ├── dataobject/im/
    │   ├── ImConversationDO.java
    │   ├── ImConversationMemberDO.java
    │   └── ImMessageDO.java
    └── mysql/im/
        ├── ImConversationMapper.java
        ├── ImConversationMemberMapper.java
        └── ImMessageMapper.java

yudao-module-system/src/main/resources/mapper/im/
├── ImConversationMapper.xml
├── ImConversationMemberMapper.xml
└── ImMessageMapper.xml
```

**前端结构（yudao-ui-admin-vue3）**：

```
src/
├── views/system/im/
│   ├── index.vue          ← 主页面（会话列表+消息区域，需重写）
│   └── ...
└── api/system/im/
    ├── conversation.ts    ← 会话接口
    ├── member.ts          ← 成员接口
    └── message.ts         ← 消息接口
```

**注意**：代码生成的前端路径格式如 `yudao-ui-admin-vue3/src/views/system/im/...`，如果你的前端项目在另一个目录（如 `e:\Work\OA\yudao-ui-admin-vue3`），需要把前端文件复制到那个项目对应目录下。

---

### 步骤 4：后端改造

代码生成的是标准 CRUD，需要按业务改造。

**ImConversationController 需要的接口**：

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/list` | 查我的会话列表（含未读数） |
| POST | `/create-single` | 创建或获取单聊会话 |
| POST | `/create-group` | 创建群聊会话 |
| PUT | `/update-name` | 修改群名 |
| DELETE | `/dismiss/{id}` | 解散群聊 |

**ImConversationMemberController 需要的接口**：

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/list/{conversationId}` | 查群成员列表 |
| POST | `/invite` | 邀请成员 |
| DELETE | `/remove` | 踢人（群主/管理员） |
| PUT | `/read/{conversationId}` | 标记该会话消息为已读 |

**ImMessageController 需要的接口**：

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/list/{conversationId}` | 分页查会话消息列表（翻页加载历史） |
| POST | `/send` | 发消息 |
| PUT | `/recall/{id}` | 撤回消息（改 status=1） |
| GET | `/read-status/{messageId}` | 群聊消息的已读/未读详情（发送者用，含 readUserList、unreadUserList） |

**Service 层关键改造点**：

- `sendMessage`：先校验是否为会话成员 → 写 `im_message` → 更新 `im_conversation` 冗余字段 → WebSocket 推送
- `createSingleConversation`：先查是否存在 → 无则新建+插入两条成员记录
- `createGroupConversation`：新建会话 → 批量插入成员记录
- `getUnreadCount`：按上面第四节的 SQL 计算

---

### 步骤 5：前端改造

代码生成的列表页是表格形式，需重写为聊天界面。

**页面布局建议**：

```
┌───────────────────────────────────────────┐
│ 左侧：会话列表（200px）│ 右侧：消息区域   │
│                        │                  │
│ [搜索框]               │ [消息气泡列表]   │
│                        │                  │
│ - 张三  未读3          │                  │
│ - 研发群 未读1         │ [输入框 + 发送]  │
│ - 李四                 │                  │
└───────────────────────────────────────────┘
```

**群聊消息气泡（发送者视角）**：
- 默认显示「2/4 已读」
- 点击可切换展开：模式一显示「张三、李四 已读」，模式二显示「王五、赵六 未读」
- 调用 `GET /message/{messageId}/read-status` 获取详情

**附件发送流程**：

```
用户选择文件
  ↓
调用 POST /admin-api/infra/file/upload（现有接口）
  ↓
返回文件 URL
  ↓
调用发消息接口，content_type=3，content=URL，file_name=原始文件名，file_size=文件大小
```

---

### 步骤 6：建菜单（放在代码就绪后）

**为什么要最后建菜单**：菜单的 `component` 字段必须指向前端存在的 Vue 组件路径，若组件未放置，点击菜单会 404。

**菜单配置**：

1. 系统管理 → 菜单管理 → 新增
2. **父级菜单**：新建「消息中心」目录级菜单（或挂在「系统管理」下）
3. 在「消息中心」下新增：

| 字段 | 值 |
|------|----|
| 菜单名称 | 我的消息 |
| 路由地址 | `myMessage` |
| 组件路径 | `system/im/index` （与前端文件路径对应） |
| 权限标识 | `system:im:query` |

4. 保存后，在「角色管理」中给对应角色勾选该菜单权限

---

### 步骤 7：WebSocket 实时推送（可选，后期加）

发消息 Service 中，入库后追加推送：

```java
// 查出该会话所有成员
List<ImConversationMemberDO> members = conversationMemberMapper.selectListByConversationId(conversationId);

// 逐一推送（过滤掉发送者自己）
members.stream()
    .filter(m -> !m.getUserId().equals(senderId))
    .forEach(m -> webSocketSenderApi.sendObject(
        UserTypeEnum.ADMIN.getValue(),
        m.getUserId(),
        "im-message",
        messageRespVO
    ));
```

前端监听 WebSocket `im-message` 类型，收到后：
- 若当前打开的是该会话 → 直接追加消息气泡
- 若不在该会话 → 会话列表未读数 +1

---

## 七、注意事项

### 7.1 单聊会话的名称和头像从哪里来

单聊会话本身没有名称和头像（`im_conversation.name` 为空），前端展示时：
- 找出会话成员中**不是自己的那一方**
- 用对方的昵称和头像展示

### 7.2 群聊建群权限控制示例

```java
// 在 ImConversationController 中
@PostMapping("/create-group")
@PreAuthorize("@ss.hasPermission('system:im:create-group')")
public CommonResult<Long> createGroupConversation(...) { ... }
```

在「角色管理」→「权限分配」中，只给允许建群的角色（如「部门领导」「管理员」）添加 `system:im:create-group`，普通员工看不到建群入口。

### 7.3 多租户

三张表均有 `tenant_id`，框架会自动注入 `WHERE tenant_id = ?` 条件，无需手动处理。

### 7.4 冗余字段的维护

`im_conversation` 中的 `last_message_id / last_message_content / last_message_time` 是冗余字段，每次发消息后必须同步更新，否则会话列表排序和摘要会不准确。

### 7.5 代码生成放错位置

解压 zip 时，路径基准是**项目根目录**（即 `yudao-module-system` 的上级）。若放错位置，Java 包路径不对，编译报错。

---

## 八、常见问题

| 问题 | 原因 | 处理 |
|------|------|------|
| 未读数总为 0 | `last_read_message_id` 没有更新 | 在「打开会话」时调用标记已读接口 |
| 单聊重复创建会话 | createSingleConversation 没做去重判断 | Service 中先查再建 |
| 群聊成员看不到旧消息 | 成员加入时间晚，消息早于成员 | 业务上允许看之前消息，不需要特殊处理 |
| 菜单 404 | component 路径与前端文件不一致 | 核对前端视图文件路径 |
| 文件 URL 无法访问 | 文件配置未设为主配置，或 domain 配置错误 | 检查「基础设施 → 文件配置」中的主配置 |
| WebSocket 推送不到 | 用户未建立 WS 连接，或 userType 传错 | 管理后台用 `UserTypeEnum.ADMIN` |

---

## 九、总结

| 方面 | 结论 |
|------|------|
| 表结构 | 三张表（会话、成员、消息），缺一不可 |
| 已读/未读 | 用 `last_read_message_id` 记在成员表，按消息 ID 比较计算 |
| 群聊已读展示 | 发送者看「2/4 已读」，可切换展开「谁已读」或「谁未读」；接收者仅看自己是否已读 |
| 单聊防重复 | 创建前先查是否已存在 A+B 的单聊会话，有则复用，无则新建 |
| 单聊/群聊 | 会话 `type` 区分，成员表统一管理，逻辑无本质差异 |
| 权限 | 通过若依现有角色+菜单权限体系控制，Controller 加 `@PreAuthorize` |
| 文件传输 | 调现有 `FileApi` 上传，URL 存入消息的 `content` 字段 |
| WebSocket | 可选，先做纯持久化版，后期再加实时推送 |
| 开发顺序 | 建表 → 代码生成 → 放代码 → 后端改造 → 前端改造 → 建菜单 |
